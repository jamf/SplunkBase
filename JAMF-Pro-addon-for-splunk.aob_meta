{"basic_builder": {"appname": "JAMF-Pro-addon-for-splunk", "friendly_name": "Jamf Pro Add-on", "version": "2.10.7", "author": "JAMF : Research", "description": "Connects to the Jamf Pro API's to pull information related to your computers.", "theme": "#3c6188", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAACmklEQVRYR2P8////f4ZBBBhBDpq1+tide0/eqFDiLgUZ4TsZodYUmQGyH+ygiv5NlLgFrrej0O8PAwMDCyWGUdtBlLgFrHf4OkhGgv9uTqS9MqVBRLUQivI2ua+nJqWIxUG/3n78+u7Zy48C33/+Yv7/j+E3uhpmVmYmQ3VpRmZmJnaqOagkwemLiCAPD5Jl/6etOPLhycv3fP/+/WcmFHKsrMw/m3O8qeegtnzfb0xMjFwgiz99+fG6fe5uof9EOATZoR2FftRJ1NycbJ9rMzx4oYb/qJywie3/fwYmQqGCLk81B8lJCn3LirABh87kZYe+Pn35gZtUx4DUU81BAc56Nyz0FDR+/f77uW7KVlhIkewmqjmoo9DvMwMDA+/5G09ur9x+TpVkl0A1UMVBzEyMf1rzfcHVRe3krd9///nLOaAOSg+zeasoLSQMcgSldSLFIaSnJvkkyttUBuSYU5cf3ly356I6uaFDcaL2d9S7a2mgAK8qehbs+/jm/Rd+qjjoyp3ntzcfuCL69+8/RmwGggRZWVj+8XCxsRhpybyw0FcEtXvgav/++/eteuIWcLanBMCjjBJDQHrvPXn7YdbqowKUmkM1B01YvP/Rizef5QaNgyjNXTCPUCWE3n74erl7/l5dSkMHJZdRYtjkZYc/P335nuzqAmttT66Dfv/5+6l28lY+cvXjrO3JNXDa8sOPH714L0uufqo6aO7a469vP3otSi3HoKehv5++/Pj09x/2ghGkGCT37fsvtjuP3t7fdey6FjUdgpHLOubs+vzh8w+qJExKHEpx5UqJ5dj0jjqIUIiOhtDQDaHG6ds/ff/xm2pVAKGQwCavpSRxM87fTB3ct4cq+MXAwPCPHMOooIeVgYEB3P8HAKcSp6SRyzYwAAAAAElFTkSuQmCC", "visible": true, "tab_version": "4.1.0", "tab_build_no": "0", "build_no": 23}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "JamfMobileDevices", "interval": "86400", "use_external_validation": true, "streaming_mode_xml": true, "name": "jamfmobiledevices", "title": "jamfMobileDevices", "description": "", "type": "customized", "parameters": [{"name": "jssUrl", "label": "Jamf Pro URL", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "trial.jamfcloud.com"}, {"name": "jssUsername", "label": "Jamf Pro Service Account", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "service_splunk_api"}, {"name": "jssPassword", "label": "Jamf Pro Service Secret", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "JXL63JDNLwNoKtZ"}, {"name": "platforms", "label": "OS Platforms", "help_string": "Which Platforms to collect", "required": false, "possible_values": [{"value": "iphone", "label": "iPhone"}, {"value": "ipad", "label": "iPad"}, {"value": "appletv", "label": "appleTV"}, {"label": "iPod", "value": "ipod"}, {"label": "Other OS", "value": "other"}], "format_type": "multi_dropdownlist", "default_value": ["iphone", "ipad", "appletv"], "placeholder": "", "type": "multi_dropdownlist", "value": ["iphone", "ipad", "appletv"]}, {"name": "excludeNoneManaged", "label": "Exclude None Managed", "help_string": "Exclude devices not marked as Managed (don't collect)", "required": false, "format_type": "checkbox", "default_value": true, "type": "checkbox", "value": true}, {"required": false, "name": "daysSinceContact", "label": "daysSinceContact", "default_value": "21", "placeholder": "", "help_string": "Devices older than this without contact will be excluded, 0= Infinity", "type": "text", "format_type": "text", "value": "5"}, {"name": "sections", "label": "Device Details to Post", "help_string": "", "required": false, "possible_values": [{"value": "security", "label": "Security"}, {"value": "purchasing", "label": "Purchasing"}, {"value": "applications", "label": "Applications"}, {"label": "Network", "value": "network"}, {"label": "Configuration Profiles", "value": "configurationProfiles"}, {"label": "Certificates", "value": "certificates"}, {"label": "Provisioning Profiles", "value": "provisioningProfiles"}, {"label": "Extension Attributes", "value": "extensionAttributes"}, {"label": "Group Memberships", "value": "groupMemberships"}, {"label": "Location", "value": "location"}, {"label": "General", "value": "general"}], "format_type": "multi_dropdownlist", "default_value": ["security", "general", "location", "groupMemberships", "purchasing", "applications"], "placeholder": "", "type": "multi_dropdownlist", "value": ["security", "general", "location", "groupMemberships", "purchasing", "applications"]}], "data_inputs_options": [{"type": "customized_var", "name": "jssUrl", "title": "Jamf Pro URL", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jssUsername", "title": "Jamf Pro Service Account", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jssPassword", "title": "Jamf Pro Service Secret", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "platforms", "title": "OS Platforms", "description": "Which Platforms to collect", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "iphone", "label": "iPhone"}, {"value": "ipad", "label": "iPad"}, {"value": "appletv", "label": "appleTV"}, {"label": "iPod", "value": "ipod"}, {"label": "Other OS", "value": "other"}], "format_type": "multi_dropdownlist", "default_value": ["iphone", "ipad", "appletv"], "placeholder": ""}, {"type": "customized_var", "name": "excludeNoneManaged", "title": "Exclude None Managed", "description": "Exclude devices not marked as Managed (don't collect)", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": true}, {"type": "customized_var", "name": "daysSinceContact", "title": "daysSinceContact", "description": "Devices older than this without contact will be excluded, 0= Infinity", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "21", "placeholder": ""}, {"type": "customized_var", "name": "sections", "title": "Device Details to Post", "description": "", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "security", "label": "Security"}, {"value": "purchasing", "label": "Purchasing"}, {"value": "applications", "label": "Applications"}, {"label": "Network", "value": "network"}, {"label": "Configuration Profiles", "value": "configurationProfiles"}, {"label": "Certificates", "value": "certificates"}, {"label": "Provisioning Profiles", "value": "provisioningProfiles"}, {"label": "Extension Attributes", "value": "extensionAttributes"}, {"label": "Group Memberships", "value": "groupMemberships"}, {"label": "Location", "value": "location"}, {"label": "General", "value": "general"}], "format_type": "multi_dropdownlist", "default_value": ["security", "general", "location", "groupMemberships", "purchasing", "applications"], "placeholder": ""}], "code": "# encoding = utf-8\n\nimport json\nfrom datetime import datetime, timedelta, timezone\nimport logging\nimport requests\nimport base64\n\nimport time\n\ntry:\n    from uapiModels import devices, jamfpro\nexcept:\n    from .uapiModels import devices, jamfpro\n\n\n# Static Variables\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # name_of_the_modular_input = definition.parameters.get('name_of_the_modular_input', None)\n    # jss_url = definition.parameters.get('jss_url', None)\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    # multiple_dropdown = definition.parameters.get('multiple_dropdown', None)\n    # radio_buttons = definition.parameters.get('radio_buttons', None)\n    # run_time = definition.parameters.get('run_time', None)\n    # write_computer_diffs = definition.parameters.get('write_computer_diffs', None)\n    pass\n\n\ndef collect_events(helper, ew):\n    \"\"\"\n    This is the main execution function\n    \"\"\"\n    headers = {\n        'User-Agent': 'splunkbase_ta-jamf-addon/2.10.5 modular/jamfdevices'\n    }\n    errors = []\n    settings = {\n        \"jamfSettings\": {\n            \"jssUrl\": helper.get_arg('jssUrl', None),\n            \"jssUsername\": helper.get_arg('jssUsername', None),\n            \"jssPassword\": helper.get_arg('jssPassword', None),\n        },\n        \"devicesCollection\": {\n            \"details\": helper.get_arg('device_collection_details', None),\n            \"daysSinceContact\": helper.get_arg('daysSinceContact', None),\n            \"excludeNoneManaged\": helper.get_arg('excludeNoneManaged', False),\n            \"platforms\": helper.get_arg('platforms', None),\n            \"sections\": helper.get_arg('sections', None)\n        },\n        \"eventWriter\": {\n            \"hostAsDeviceName\": helper.get_arg('host_as_device_name', None),\n            \"eventTimeFormat\": helper.get_arg('event_time_format', None)\n        },\n        \"outbound\": {\n            \"use_proxy\": helper.get_arg('use_proxy', None),\n            \"verifyTLS\": True,\n            \"retryCount\": 3,\n            \"timeOut\": 60\n        }\n    }\n    # functions:\n\n    def writeEvent(thisEvent=None):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #\n        #\n\n        if \"index\" in thisEvent:\n            index = thisEvent['index']\n            del thisEvent['index']\n        else:\n            index = helper.get_output_index()\n\n        if \"host\" in thisEvent:\n            host = thisEvent['host']\n            del thisEvent['host']\n        else:\n            host = \"Jamf-TA-AddOn\"\n\n        if \"sourcetype\" in thisEvent:\n            sourcetype = thisEvent['sourcetype']\n            del thisEvent['sourcetype']\n        else:\n            sourcetype = \"_json\"\n\n        if \"time\" in thisEvent:\n            eventTime = thisEvent['time']\n            del thisEvent['time']\n        else:\n            eventTime = time.time()\n\n        if \"source\" in thisEvent:\n            source = thisEvent['source']\n            del thisEvent['source']\n        else:\n            source = \"jssInventory\"\n\n        if index is not None:\n            event = helper.new_event(data=json.dumps(thisEvent, ensure_ascii=False), source=source, time=eventTime,\n                                     host=host,\n                                     sourcetype=sourcetype)\n        else:\n            event = helper.new_event(data=json.dumps(thisEvent, ensure_ascii=False), source=source, time=eventTime,\n                                     host=host,\n                                     sourcetype=sourcetype)\n        ew.write_event(event)\n        return True\n\n    # Jamf URL\n    if str(settings['jamfSettings']['jssUrl'])[-1] != '/':\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'] + '/'\n\n    if str(settings['jamfSettings']['jssUrl']).__contains__(\"http://\"):\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'].replace(\"http://\", \"\")\n\n    if str(settings['jamfSettings']['jssUrl']).__contains__(\"https://\"):\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'].replace(\"https://\", \"\")\n\n    #\n    # Functions:\n    #\n    jpro = jamfpro.JamfPro(jamf_url=settings['jamfSettings']['jssUrl'], jamf_username=settings['jamfSettings']['jssUsername'], jamf_password=settings['jamfSettings']['jssPassword'], helper=helper, headers=headers)\n    mobile_devices = jpro.getMobileDevices()\n    # Collect Computers Process each time\n    \n    metaChecker = devices.filterMobileDeviceMeta()\n    if int(settings['devicesCollection']['daysSinceContact']) == 0:\n        endEpoch = 0\n    else:\n        endEpoch = int(str(time.time()).split(\".\")[0]) - int(settings['devicesCollection']['daysSinceContact']) * 86400\n\n    #endEpoch = 0\n    \n    countProcess = 0\n    \n    countPass = 0\n    \n    for mobile_device in mobile_devices:\n        process, reason = metaChecker.keepDevice(deviceMeta=mobile_device,\n                                     endEpoch=endEpoch,\n                                     excludeNoneManaged=settings['devicesCollection']['excludeNoneManaged'],\n                                     platformIn=settings['devicesCollection']['platforms'])\n        if process:\n            try:\n                deviceDetails = jpro.getMobileDevicesDetails(id=mobile_device['id'], apiVersion=\"JSSResource\")\n                thisDevice = devices.mobileDeviceJSSResource(uapiModel=deviceDetails['mobile_device'])\n                events = thisDevice.getSplunkEvents(sections=settings['devicesCollection']['sections'], buildings={}, departments={})\n                for event in events:\n                    writeEvent(thisEvent=event)\n                countProcess += 1\n            except Exception as e:\n                errors.append(f\"Error with Device {str(e)}\")\n        else:\n            countPass += 1\n\n    print(f\"Count Process: {countProcess}, Count Pass: {countPass}\")\n", "customized_options": [{"name": "jssUrl", "value": "trial.jamfcloud.com"}, {"name": "jssUsername", "value": "service_splunk_api"}, {"name": "platforms", "value": ["iphone", "ipad", "appletv"]}, {"name": "excludeNoneManaged", "value": true}, {"name": "daysSinceContact", "value": "5"}, {"name": "sections", "value": ["security", "general", "location", "groupMemberships", "purchasing", "applications"]}], "uuid": "148dac8e1a9d49cdbfdcbf0962d69dba", "sample_count": 0}, {"index": "default", "sourcetype": "Jamf", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "jamfcomputers", "title": "JamfComputers", "description": "Jamf Pro computer collectors", "type": "customized", "parameters": [{"name": "name_of_the_modular_input", "label": "Name of the Modular Input", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "Name", "type": "text", "value": "aTestRun"}, {"name": "jss_url", "label": "JSS URL", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "trial.jamfcloud.com"}, {"name": "jss_username", "label": "Username", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "service_splunk_api"}, {"name": "jss_password", "label": "Password", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "JXL63JDNLwNoKtZ"}, {"name": "excludeNoneManaged", "label": "Exclude Non Managed Devices", "help_string": "If a device is not managed Exclude it", "required": false, "format_type": "checkbox", "default_value": true, "type": "checkbox", "value": true}, {"name": "sections", "label": "Sections", "help_string": "General and User_and_Location are included by default: Excluded are Fonts, Services, Package Receipts, Content Caching, iBeacons, Plugins, and Attachments.", "required": false, "possible_values": [{"value": "DISK_ENCRYPTION", "label": "Disk Encryption"}, {"value": "PURCHASING", "label": "Purchasing"}, {"label": "Applications", "value": "APPLICATIONS"}, {"label": "Disk Information", "value": "STORAGE"}, {"label": "Printers", "value": "PRINTERS"}, {"label": "Hardware", "value": "HARDWARE"}, {"label": "Local User Accounts", "value": "LOCAL_USER_ACCOUNTS"}, {"label": "Certificates", "value": "CERTIFICATES"}, {"label": "Security", "value": "SECURITY"}, {"label": "Operating System", "value": "OPERATING_SYSTEM"}, {"label": "Licensed Software", "value": "LICENSED_SOFTWARE"}, {"label": "Software Updates", "value": "SOFTWARE_UPDATES"}, {"label": "Extension Attributes", "value": "EXTENSION_ATTRIBUTES"}, {"label": "Group Memberships", "value": "GROUP_MEMBERSHIPS"}], "format_type": "multi_dropdownlist", "default_value": ["PURCHASING", "APPLICATIONS", "HARDWARE", "OPERATING_SYSTEM", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS", "SECURITY"], "placeholder": "", "type": "multi_dropdownlist", "value": ["DISK_ENCRYPTION", "PURCHASING", "APPLICATIONS", "STORAGE", "PRINTERS", "HARDWARE", "LOCAL_USER_ACCOUNTS", "CERTIFICATES", "SECURITY", "OPERATING_SYSTEM", "LICENSED_SOFTWARE", "SOFTWARE_UPDATES", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS"]}, {"name": "days_since_contact", "label": "Days Since Contact", "help_string": "Exclude devices that haven't been contacted in the above days. Suggest 7, 14, 30, 90 days. Refer to your own environment. \n\n0 = Unlimited", "required": false, "format_type": "text", "default_value": "0", "placeholder": "0", "type": "text", "value": "0"}, {"name": "event_time_format", "label": "Event Time format", "help_string": "Write the \"TIME\" field as either when the device inventoried, was last contacted, or when the Script runs", "required": false, "possible_values": [{"value": "timeAsScript", "label": "Time as Script Run"}], "format_type": "radiogroup", "default_value": "timeAsScript", "type": "radiogroup", "value": "timeAsScript"}, {"name": "host_as_device_name", "label": "Host as Device Name", "help_string": "Writes the devices name as the Host Name.", "required": false, "format_type": "checkbox", "default_value": true, "type": "checkbox", "value": true}, {"name": "use_proxy", "label": "Use proxy", "help_string": "Use the System or Per-App Proxy", "required": false, "format_type": "checkbox", "default_value": false, "type": "checkbox", "value": false}], "data_inputs_options": [{"type": "customized_var", "name": "name_of_the_modular_input", "title": "Name of the Modular Input", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": "Name"}, {"type": "customized_var", "name": "jss_url", "title": "JSS URL", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jss_username", "title": "Username", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jss_password", "title": "Password", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "excludeNoneManaged", "title": "Exclude Non Managed Devices", "description": "If a device is not managed Exclude it", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": true}, {"type": "customized_var", "name": "sections", "title": "Sections", "description": "General and User_and_Location are included by default: Excluded are Fonts, Services, Package Receipts, Content Caching, iBeacons, Plugins, and Attachments.", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "DISK_ENCRYPTION", "label": "Disk Encryption"}, {"value": "PURCHASING", "label": "Purchasing"}, {"label": "Applications", "value": "APPLICATIONS"}, {"label": "Disk Information", "value": "STORAGE"}, {"label": "Printers", "value": "PRINTERS"}, {"label": "Hardware", "value": "HARDWARE"}, {"label": "Local User Accounts", "value": "LOCAL_USER_ACCOUNTS"}, {"label": "Certificates", "value": "CERTIFICATES"}, {"label": "Security", "value": "SECURITY"}, {"label": "Operating System", "value": "OPERATING_SYSTEM"}, {"label": "Licensed Software", "value": "LICENSED_SOFTWARE"}, {"label": "Software Updates", "value": "SOFTWARE_UPDATES"}, {"label": "Extension Attributes", "value": "EXTENSION_ATTRIBUTES"}, {"label": "Group Memberships", "value": "GROUP_MEMBERSHIPS"}], "format_type": "multi_dropdownlist", "default_value": ["PURCHASING", "APPLICATIONS", "HARDWARE", "OPERATING_SYSTEM", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS", "SECURITY"], "placeholder": ""}, {"type": "customized_var", "name": "days_since_contact", "title": "Days Since Contact", "description": "Exclude devices that haven't been contacted in the above days. Suggest 7, 14, 30, 90 days. Refer to your own environment. \n\n0 = Unlimited", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "0", "placeholder": "0"}, {"type": "customized_var", "name": "event_time_format", "title": "Event Time format", "description": "Write the \"TIME\" field as either when the device inventoried, was last contacted, or when the Script runs", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "timeAsScript", "label": "Time as Script Run"}], "format_type": "radiogroup", "default_value": "timeAsScript"}, {"type": "customized_var", "name": "host_as_device_name", "title": "Host as Device Name", "description": "Writes the devices name as the Host Name.", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": true}, {"type": "customized_var", "name": "use_proxy", "title": "Use proxy", "description": "Use the System or Per-App Proxy", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}], "code": "# encoding = utf-8\n\nimport json\nfrom datetime import datetime, timedelta, timezone\nimport logging\nimport requests\nimport base64\n\nimport time\n\ntry:\n    from uapiModels import devices, jamfpro\nexcept:\n    from .uapiModels import devices, jamfpro\n\n\n\n# Static Variables\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # name_of_the_modular_input = definition.parameters.get('name_of_the_modular_input', None)\n    # jss_url = definition.parameters.get('jss_url', None)\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    # multiple_dropdown = definition.parameters.get('multiple_dropdown', None)\n    # radio_buttons = definition.parameters.get('radio_buttons', None)\n    # run_time = definition.parameters.get('run_time', None)\n    # write_computer_diffs = definition.parameters.get('write_computer_diffs', None)\n    pass\n\n\ndef collect_events(helper, ew):\n    \"\"\"\n    This is the main execution function\n    \"\"\"\n    headers = {\n        'User-Agent': 'splunkbase_ta-jamf-addon/2.10.5 modular/jamfcomputers'\n    }\n    errors = []\n    errors = []\n    settings = {\n        \"jamfSettings\": {\n            \"jssUrl\": helper.get_arg('jss_url', None),\n            \"jssUsername\": helper.get_arg('jss_username', None),\n            \"jssPassword\": helper.get_arg('jss_password', None),\n        },\n        \"computerCollection\": {\n            \"details\": helper.get_arg('computer_collection_details', None),\n            \"daysSinceContact\": helper.get_arg('days_since_contact', None),\n            \"excludeNoneManaged\": helper.get_arg('excludeNoneManaged', None),\n            \"sections\": helper.get_arg('sections', None)\n        },\n        \"eventWriter\": {\n            \"hostAsDeviceName\": helper.get_arg('host_as_device_name', None),\n            \"eventTimeFormat\": helper.get_arg('event_time_format', None)\n        },\n        \"outbound\": {\n            \"use_proxy\": helper.get_arg('use_proxy', None),\n            \"verifyTLS\": True,\n            \"retryCount\": 3,\n            \"timeOut\": 60\n        }\n    }\n    # Clean Up Checks\n\n    # Jamf URL\n    if str(settings['jamfSettings']['jssUrl'])[-1] != '/':\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'] + '/'\n\n    if str(settings['jamfSettings']['jssUrl']).__contains__(\"http://\"):\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'].replace(\"http://\", \"\")\n\n    if str(settings['jamfSettings']['jssUrl']).__contains__(\"https://\"):\n        settings['jamfSettings']['jssUrl'] = settings['jamfSettings']['jssUrl'].replace(\"https://\", \"\")\n\n    #\n    # Functions:\n    #\n\n    def writeEvent(thisEvent=None):\n        \"\"\"\n        \"\"\"\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #\n        #\n\n        if \"index\" in thisEvent:\n            index = thisEvent['index']\n            del thisEvent['index']\n        else:\n            index = helper.get_output_index()\n\n        if \"host\" in thisEvent:\n            host = thisEvent['host']\n            del thisEvent['host']\n        else:\n            host = \"Jamf-TA-AddOn\"\n\n        if \"sourcetype\" in thisEvent:\n            sourcetype = thisEvent['sourcetype']\n            del thisEvent['sourcetype']\n        else:\n            sourcetype = \"_json\"\n\n        if \"time\" in thisEvent:\n            eventTime = thisEvent['time']\n            del thisEvent['time']\n        else:\n            eventTime = time.time()\n\n        if \"source\" in thisEvent:\n            source = thisEvent['source']\n            del thisEvent['source']\n        else:\n            source = \"jssInventory\"\n\n        if index is not None:\n            event = helper.new_event(data=json.dumps(thisEvent, ensure_ascii=False), source=source, time=eventTime,\n                                     host=host,\n                                     sourcetype=sourcetype)\n        else:\n            event = helper.new_event(data=json.dumps(thisEvent, ensure_ascii=False), source=source, time=eventTime,\n                                     host=host,\n                                     sourcetype=sourcetype)\n        ew.write_event(event)\n        return True\n\n    def getComputersPage(pageNumber=0, jss=None):\n\n        FILTERS = {}\n        if settings['computerCollection']['excludeNoneManaged']:\n            FILTERS['managed'] = {'value': True}\n        if settings['computerCollection']['daysSinceContact'] != str(0):\n            try:\n                time_s = datetime.now(timezone.utc) - timedelta(\n                    days=int(settings['computerCollection']['daysSinceContact']))\n                FILTERS['lastContactTime'] = {\n                    'value': time_s.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"),\n                    'operator': '>'\n                }\n            except:\n                errors.append(\n                    {'type': 'Filter Value Error', 'value': settings['computerCollection']['daysSinceContact']})\n\n        sections = settings['computerCollection']['sections']\n\n        requiredSections = ['GENERAL', 'USER_AND_LOCATION', 'HARDWARE']\n\n        for requiredSection in requiredSections:\n            if requiredSection not in sections:\n                sections.append(requiredSection)\n\n        computers = jss.getComputersPageNumber(filters=FILTERS, sections=sections,\n                                               sortKey=\"&sort=general.reportDate%3Adesc\", pageNumber=pageNumber)\n        return computers\n        pass\n\n    # Collect Computers Process each time\n    notDone = True\n    pageCount = 0\n    meta_keys = ['supervised', 'managed', 'name', 'serial_number', 'udid', 'id', 'assigned_user', 'department',\n                 'building', 'room', 'eventID', 'reportDate']\n\n    if settings['eventWriter']['eventTimeFormat'] == \"timeAsScript\":\n        timeAs = \"script\"\n    if settings['eventWriter']['eventTimeFormat'] == \"timeAsReport\":\n        timeAs = \"report\"\n\n    jamfPro = jamfpro.JamfPro(jamf_url=settings['jamfSettings']['jssUrl'],\n                                jamf_username=settings['jamfSettings']['jssUsername'],\n                                jamf_password=settings['jamfSettings']['jssPassword'],\n                                helper=helper, headers=headers)\n\n    while notDone:\n        theseComputers = getComputersPage(pageNumber=pageCount, jss=jamfPro)\n        if theseComputers.__len__() == 0:\n            return None\n        else:\n            pageCount += 1\n            for computer in theseComputers:\n                try:\n                    newComputer = devices.JamfComputer(computerDetails=computer, source=\"uapi\")\n                    events = newComputer.splunk_hec_events(meta_keys=meta_keys,\n                                                           nameAsHost=settings['eventWriter']['hostAsDeviceName'],\n                                                           timeAs=timeAs)\n\n                    for event in events:\n                        writeEvent(event)\n                except:\n                    error_event = {\n                        \"messages\": \"An error occured while processing a computer\",\n                        \"jss_id\": computer['id'],\n                        \"jss\": settings['jamfSettings']['jssUrl'],\n                        \"sourcetype\": \"jamf:jssInventory:errorCode\"\n                    }\n\n                    writeEvent(error_event)\n", "customized_options": [{"name": "name_of_the_modular_input", "value": "aTestRun"}, {"name": "jss_url", "value": "trial.jamfcloud.com"}, {"name": "jss_username", "value": "service_splunk_api"}, {"name": "excludeNoneManaged", "value": true}, {"name": "sections", "value": ["DISK_ENCRYPTION", "PURCHASING", "APPLICATIONS", "STORAGE", "PRINTERS", "HARDWARE", "LOCAL_USER_ACCOUNTS", "CERTIFICATES", "SECURITY", "OPERATING_SYSTEM", "LICENSED_SOFTWARE", "SOFTWARE_UPDATES", "EXTENSION_ATTRIBUTES", "GROUP_MEMBERSHIPS"]}, {"name": "days_since_contact", "value": "0"}, {"name": "event_time_format", "value": "timeAsScript"}, {"name": "host_as_device_name", "value": true}, {"name": "use_proxy", "value": false}], "uuid": "808639f28b8e4cf1b8a3a23387421ca5", "sample_count": "0"}, {"index": "default", "sourcetype": "JamfModularInput", "interval": "3600", "use_external_validation": true, "streaming_mode_xml": true, "sample_count": 0, "uuid": "1c09cb214a8442d486dc65548d0c6da3", "code": "# encoding = utf-8\n\nimport math\nimport uuid\nimport time\nimport sys, os\n\ntry:\n    import xml.etree.cElementTree as ElementTree\nexcept ImportError:\n    import xml.etree.ElementTree as ElementTree\n\ntry:\n    import jamf_pro_models\nexcept:\n    from . import jamf_pro_models\n\ntry:\n    from uapiModels import devices, jamfpro\nexcept:\n    from .uapiModels import devices, jamfpro\n\n\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), \"..\", \"lib\"))\n\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # name_of_the_modular_input = definition.parameters.get('name_of_the_modular_input', None)\n    # jss_url = definition.parameters.get('jss_url', None)\n    # api_call = definition.parameters.get('api_call', None)\n    # search_name = definition.parameters.get('search_name', None)\n    # custom_index_name = definition.parameters.get('custom_index_name', None)\n    # custom_host_name = definition.parameters.get('custom_host_name', None)\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    pass\n\n\ndef collect_events(helper, ew):\n    name_of_the_modular_input = helper.get_arg('name_of_the_modular_input', None)\n    url = helper.get_arg('jss_url', None)\n    api_call = helper.get_arg('api_call', None)\n    search_name = helper.get_arg('search_name', None)\n    username = helper.get_arg('username', None)\n    password = helper.get_arg('password', None)\n    index = helper.get_arg('custom_index_name', 'main')\n    host = helper.get_arg('custom_host_name', 'localhost')\n    maxCharLength = 9500\n    call_uuid = uuid.uuid4()\n\n    headers = {\n        'User-Agent': f'splunkbase_ta-jamf-addon/2.10.5 modular/jamfClassic-search_name'\n    }\n\n    #\n    #   Verify JSS URL\n    #\n    if url.__contains__(\"http://\"):\n        url = url.replace(\"http://\", \"\")\n    if url.__contains__(\"https://\"):\n        url = url.replace(\"https://\", \"\")\n    if not url.endswith(\"/\"):\n        url = url + \"/\"\n    url = url\n\n    jss = jamfpro.JamfPro(jamf_url=url, jamf_username=username, jamf_password=password, helper=helper, headers=headers)\n\n    def writeStringTo_Event_withParsing(DATA):\n        root = ElementTree.fromstring(DATA)\n        if root.tag == \"computer\":\n            jamf_computer = jamf_pro_models.jamf_pro_computer()\n            jamf_computer.build_from_string(DATA, \"computer\")\n            string_list = jamf_computer.paginate(create_event_id=True, max_char_length=maxCharLength)\n            for line in string_list:\n                writeStringTo_Event(line)\n            # writeStringTo_Event(DATA)\n        elif root.tag == \"mobile_device\":\n            jamf_mobile = jamf_pro_models.jamf_pro_mobile_device()\n            jamf_mobile.build_from_string(DATA, \"mobile_device\")\n            string_list = jamf_mobile.paginate(create_event_id=True)\n            for line in string_list:\n                writeStringTo_Event(line)\n        elif root.tag == \"mac_application\":\n            macapplication = jamf_pro_models.MacApplication()\n            macapplication.build_from_string(DATA, \"JSSResource\")\n            string_list = macapplication.paginate()\n            for line in string_list:\n                writeStringTo_Event(line)\n        else:\n            data = ElementTree.fromstring(DATA)\n            # writeStringTo_Event(ElementTree.tostring(data))\n            writeStringTo_Event(DATA)\n\n    def writeStringTo_Event(event_string):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #\n        #\n        if event_string.__len__() < maxCharLength:\n            xml_event = ElementTree.fromstring(event_string)\n            event = helper.new_event(data=ElementTree.tostring(xml_event, encoding=\"utf-8\", method=\"xml\").decode(),\n                                     index=index, host=host)\n            # event = helper.new_event(data=event_string, index=index, host=host)\n            ew.write_event(event)\n            return True\n        else:\n            root = ElementTree.Element(\"Error\")\n            ElementTree.SubElement(root, 'error').text = \"The XML was too long\"\n            writeStringTo_Event(ElementTree.tostring(root))\n            root = ElementTree.fromstring(event_string)\n            children = root.getchildren\n\n            debug = True\n            if debug:\n                event = helper.new_event(data=str(event_string.__len__()), index=index, host=host)\n                ew.write_event(event)\n\n            # for n in children\n            #    writeStringTo_Event(ElementTree.tostring(n))\n            # for self in root.find('self'):\n            # writeStringTo_Event( ElementTree.tostring(self))\n\n        return False\n\n    def writeStringTo_Event_wTime(event_string, event_time):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #\n        #\n        if event_string.__len__() < maxCharLength:\n            event = helper.new_event(data=str(event_string), index=index, host=host, time=event_time)\n            ew.write_event(event)\n            return True\n        else:\n            root = ElementTree.Element(\"Error\")\n            ElementTree.SubElement(root, 'error').text = \"The XML was too long\"\n            writeStringTo_Event(ElementTree.tostring(root))\n\n            root = ElementTree.fromstring(event_string)\n            children = root.getchildren\n\n            debug = True\n            if debug:\n                event = helper.new_event(data=str(event_string.__len__()), index=index, host=host)\n                ew.write_event(event)\n\n            # for n in children\n            #    writeStringTo_Event(ElementTree.tostring(n))\n            # for self in root.find('self'):\n            # writeStringTo_Event( ElementTree.tostring(self))\n\n        return False\n\n    api_retries = 0\n\n    def api_get_Call(endPoint):\n\n        #\n        #   JSSResources API Call\n        #\n\n        api_family = \"\"\n        if endPoint.__contains__(\"uapi/\"):\n            api_family = \"uapi\"\n        if endPoint.__contains__(\"JSSResource/\"):\n            api_family = \"classic\"\n\n        if api_family == \"classic\":\n            context = None\n            isDone = False\n            tryCount = 0\n            while not isDone:\n\n                #r = requests.get(endPoint, auth=(username, password), headers={'Accept': 'application/xml'}, verify=False)\n                r = jss.getJSSResourceXML(endpoint=endPoint)\n                status_code = r.status_code\n                resp = r.content\n                # https://developer.jamf.com/documentation for status code information\n                if (status_code == 200):\n                    #   Request successful\n                    isDone = True\n                    context = r.content\n                if (status_code == 201):\n                    #   Request to create or update object successful\n                    context = r.content\n                if (status_code == 400):\n                    #   Bad request. Verify the syntax of the request specifically the XML body.\n                    pass\n                if (status_code == 401):\n                    root = ElementTree.Element(\"Error\")\n                    ElementTree.SubElement(root, 'error').text = \"API Auth Error\"\n                    writeStringTo_Event(ElementTree.tostring(root))\n                    context = ElementTree.Element(\"error\")\n                    isDone = True\n                    pass\n                if (status_code == 403):\n                    #   Invalid permissions. Verify the account being used has the proper permissions for the object/resource you are trying to access.\n                    pass\n                if (status_code == 404):\n                    #   Object or resouce is not found\n                    pass\n                if (status_code == 409):\n                    #   Conflict\n                    pass\n                if (status_code == 500):\n                    #   Internal server error. Retry the request or contact Jamf support if the error is persistent.\n                    pass\n\n\n        return context\n        #\n        #   End of the API Call Function\n        #\n\n    if api_call == \"computer\":\n        #\n        #   make the API Call\n        #\n        jss_url = \"%sJSSResource/advancedcomputersearches/name/%s\" % (url, search_name)\n        #response = requests.get(jss_url, auth=(username, password), headers={'Accept': 'application/xml'}, verify=False)\n        response = jss.getJSSResourceXML(endpoint=jss_url)\n        tree = ElementTree.fromstring(response.content)\n        #\n        #   Start Advanced Computer\n        #\n\n        #\n        #   Chunk list is a list of the XML fields that we want to farm out to their own XML data sets\n        #\n        chunk_list = list()\n        # chunk_list.append(\"Applications\")\n        # chunk_list.append(\"Computer_Group\")\n        chunk_list.append(\"Running_Services\")\n\n        #\n        #   Pull the computers out of the Advanced Computer Search\n        #\n\n        computers_list = tree.find('computers')\n        computers = computers_list.findall('computer')\n        for computer in computers:\n\n            #\n            #   keyValue is an Abstract name for the values in Chunk List it will pull it out of the primary XML\n            #\n            for keyValue in chunk_list:\n                if computer.find(keyValue):\n                    keyXML = computer.find(keyValue)\n                    # Get the lenght of the string representation of the XML document\n                    key_char_length = ElementTree.tostring(keyXML).__len__()\n                    if key_char_length < maxCharLength:\n                        #\n                        #   If this is under 10k just go ahead and write to the event reader\n                        #\n                        root = ElementTree.Element(\"computer\")\n                        ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                        root.append(keyXML)\n                        writeStringTo_Event(ElementTree.tostring(root))\n                    else:\n                        #\n                        #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                        #\n                        chunk_ID = str(uuid.uuid4())\n                        num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                        #\n                        #   Create an array of XML documents\n                        #\n                        root_list = []\n                        for i in range(0, int(num_XML)):\n                            root = ElementTree.Element(keyValue)\n                            root_list.append(root)\n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n\n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = keyXML.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, num_XML))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n\n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"computer\")\n                            ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                            root.append(fin_xml)\n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                            root.append(chunk_uuid)\n\n                            # writeStringTo_Event( ElementTree.tostring(chunk_uuid) )\n\n                            writeStringTo_Event(ElementTree.tostring(root))\n\n                    #\n                    #   Remove the Key Index field from the XML\n                    #\n                    computer.remove(keyXML)\n            #\n            #   Post Data chunking... This *should* be under 10k char now, tune it with chunk list\n            #\n\n            data = ElementTree.tostring(computer)\n\n            #\n            #   Check to see if it needs chunking and if it still needs it chunk it on childs\n            #\n            if data.__len__() < maxCharLength:\n                # print (data)\n                writeStringTo_Event(data)\n\n            else:\n                num_XML = math.ceil(data.__len__() / maxCharLength) + 1\n                #\n                #   Create an array of XML documents\n                #\n                root_list = []\n                chunk_ID = str(uuid.uuid4())\n                for i in range(0, int(num_XML)):\n                    root = ElementTree.Element(\"computer\")\n                    ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                    chunk_uuid = ElementTree.Element(\"pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i + 1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                    root.append(chunk_uuid)\n\n                    root_list.append(root)\n\n                #\n                #   Get a list of the 1st level children in the XML document keeping the same structure\n                #\n\n                #\n                #   Need to remove ID from XML since it will be a duplicate in 1 of them.\n                #\n\n                computer.remove(computer.find(\"id\"))\n                #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                key_chield = computer.getchildren()\n                i = 0\n                for child in key_chield:\n                    # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                    root_list[int(math.fmod(i, num_XML))].append(child)\n                    i = i + 1\n                #\n                #   Iterate through the finished XML documents and write to the event writer.\n                #\n\n                for fin_xml in root_list:\n                    writeStringTo_Event(ElementTree.tostring(fin_xml))\n\n            #\n            # End of Computers For Loop\n            #\n        #\n        # End of Advanced Computers Section\n        #\n\n    elif api_call == \"mobile_device\":\n        jss_url = \"%sJSSResource/advancedmobiledevicesearches/name/%s\" % (url, search_name)\n        #response = requests.get(jss_url, auth=(username, password), headers={'Accept': 'application/xml'}, verify=False)\n        response = jss.getJSSResourceXML(endpoint=jss_url)\n        tree = ElementTree.fromstring(response.content)\n\n        #\n        #   Chunk list is a list of the XML fields that we want to farm out to their own XML data sets\n        #\n        chunk_list = list()\n        chunk_list.append(\"Display_Name\")\n        chunk_list.append(\"Capacity_MB\")\n        chunk_list.append(\"Device_Locator_Service_Enabled\")\n\n        mobile_devices_list = tree.find('mobile_devices')\n        mobile_devices = mobile_devices_list.findall('mobile_device')\n        for mobile_device in mobile_devices:\n            #\n            #   keyValue is an Abstract name for the values in Chunk List it will pull it out of the primary XML\n            #\n            for keyValue in chunk_list:\n                if mobile_device.findall(keyValue):\n                    # event = helper.new_event(data=keyValue, index=index, host=host)\n                    # ew.write_event(event)\n                    keyXML = mobile_device.find(keyValue)\n                    # Get the lenght of the string representation of the XML document\n                    key_char_length = ElementTree.tostring(keyXML).__len__()\n                    if key_char_length < maxCharLength:\n                        #\n                        #   If this is under 10k just go ahead and write to the event reader\n                        #\n\n                        root = ElementTree.Element(\"mobile_device\")\n                        ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                        sub_root = ElementTree.Element(keyValue)\n                        root.append(keyXML)\n                        # print(ElementTree.tostring(root))\n                        writeStringTo_Event(ElementTree.tostring(root))\n                    else:\n                        #\n                        #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                        #\n\n                        num_XML = math.ceil(key_char_length / maxCharLength) + 1\n\n                        #\n                        #   Create an array of XML documents\n                        #\n                        chunk_ID = uuid.uuid4()\n                        root_list = []\n                        for i in range(0, int(num_XML)):\n                            root = ElementTree.Element(keyValue)\n                            root_list.append(root)\n\n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n\n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = keyXML.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, num_XML))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n\n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"mobile_device\")\n                            ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                            root.append(fin_xml)\n                            event = helper.new_event(data=ElementTree.tostring(fin_xml), index=index, host=host)\n\n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i + 1)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n\n                            # Finally Write it\n                            writeStringTo_Event(ElementTree.tostring(fin_xml))\n                    #\n                    #   Remove the Key Index field from the XML\n                    #\n                    mobile_device.remove(keyXML)\n            #\n            #   Post Data chunking... This *should* be under 10k char now, tune it with chunk list\n            #\n\n            data = ElementTree.tostring(mobile_device)\n\n            #\n            #   Check to see if it needs chunking and if it still needs it chunk it on childs\n            #\n            if data.__len__() < maxCharLength:\n                writeStringTo_Event(data)\n            else:\n                num_XML = math.ceil(data.__len__() / maxCharLength) + 1\n                #\n                #   Create an array of XML documents\n                #\n                chunk_ID = str(uuid.uuid4())\n                root_list = []\n                for i in range(0, int(num_XML)):\n                    root = ElementTree.Element(\"mobile_device\")\n                    ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                    chunk_uuid = ElementTree.Element(\"pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i + 1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                    root.append(chunk_uuid)\n                    root_list.append(root)\n                #\n                #   Get a list of the 1st level children in the XML document keeping the same structure\n                #\n\n                #\n                #   Need to remove ID from XML since it will be a duplicate in 1 of them.\n                #\n                mobile_device.remove(mobile_device.find(\"id\"))\n                #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                key_chield = mobile_device.getchildren()\n                i = 0\n                for child in key_chield:\n                    # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                    root_list[int(math.fmod(i, num_XML))].append(child)\n                    i = i + 1\n                #\n                #   Iterate through the finished XML documents and write to the event writer.\n                #\n\n                for fin_xml in root_list:\n                    # print(ElementTree.tostring(fin_xml))\n                    event = helper.new_event(data=ElementTree.tostring(fin_xml), index=index, host=host)\n                    writeStringTo_Event(ElementTree.tostring(fin_xml))\n\n            #\n            # End of mobile_devices For Loop\n            #\n        #\n        # End of Advanced mobile_devices Section\n        #\n\n\n    elif api_call == \"custom\":\n        if search_name.startswith(\"/\"):\n            search_name = search_name.replace(\"/\", \"\", 1)\n\n        if search_name.endswith(\"/\"):\n            search_name = search_name[:-1]\n\n        jss_url = url + search_name\n\n        resp_string = api_get_Call(jss_url)\n        resp_xml = ElementTree.fromstring(api_get_Call(jss_url))\n\n        if search_name.__contains__(\"/name/\"):\n            writeStringTo_Event(resp_string)\n            return\n        else:\n            children = resp_xml.getchildren()\n            for name in children:\n                if name.findall(\"id\"):\n                    try:\n                        newCall = jss_url + \"/id/\" + name.find(\"id\").text\n                        data = api_get_Call(newCall)\n                        writeStringTo_Event_withParsing(data)\n                    except Exception as e:\n                        pass\n\n    #\n    #   Start Here For Async Tests\n    #\n\n\n\n\n", "parameters": [{"name": "name_of_the_modular_input", "label": "Name of the Modular Input", "help_string": "Unique Input Name for the data ", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "test"}, {"name": "jss_url", "label": "JSS URL", "help_string": "Base URL for JAMF instance", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://trial.jamfcloud.com"}, {"name": "username", "label": "Username", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "service_splunk_api"}, {"name": "password", "label": "Password", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "JXL63JDNLwNoKtZ"}, {"name": "api_call", "label": "API Call Name", "help_string": "API Call Name", "required": true, "possible_values": [{"label": "Computers", "value": "computer"}, {"label": "Mobile Devices", "value": "mobile_device"}, {"label": "Custom API", "value": "custom"}], "format_type": "radiogroup", "default_value": "", "type": "radiogroup", "value": "computer"}, {"name": "search_name", "label": "Search Name", "help_string": "Preconfigured Advanced Search to call or Custom API call, refer to documentation", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "/JSSResource/computers"}, {"name": "custom_host_name", "label": "Custom Host Name", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"name": "custom_index_name", "label": "Custom Index Name", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}], "customized_options": [{"name": "name_of_the_modular_input", "value": "test"}, {"name": "jss_url", "value": "https://trial.jamfcloud.com"}, {"name": "username", "value": "service_splunk_api"}, {"name": "api_call", "value": "computer"}, {"name": "search_name", "value": "*Compliance - Gatekeeper Disabled"}, {"name": "custom_host_name", "value": ""}, {"name": "custom_index_name", "value": ""}], "title": "jamf", "description": "", "type": "customized", "name": "jamf", "data_inputs_options": [{"type": "customized_var", "name": "name_of_the_modular_input", "title": "Name of the Modular Input", "description": "Unique Input Name for the data ", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "jss_url", "title": "JSS URL", "description": "Base URL for JAMF instance", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "username", "title": "Username", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "password", "title": "Password", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "api_call", "title": "API Call Name", "description": "API Call Name", "required_on_edit": false, "required_on_create": true, "possible_values": [{"label": "Computers", "value": "computer"}, {"label": "Mobile Devices", "value": "mobile_device"}, {"label": "Custom API", "value": "custom"}], "format_type": "radiogroup", "default_value": ""}, {"type": "customized_var", "name": "search_name", "title": "Search Name", "description": "Preconfigured Advanced Search to call or Custom API call, refer to documentation", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "custom_host_name", "title": "Custom Host Name", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "custom_index_name", "title": "Custom Index Name", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}]}]}, "field_extraction_builder": {"JamfModularInput": {"is_parsed": true, "data_format": "xml"}, "Jamf": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}, "credential_settings": []}}, "sourcetype_builder": {"JamfModularInput": {"metadata": {"extractions_count": 0, "data_input_name": "jamf", "cims_count": 0, "event_count": 0}}, "Jamf": {"metadata": {"event_count": 0, "data_input_name": "jamfcomputers", "extractions_count": 0, "cims_count": 0}}, "JamfMobileDevices": {"metadata": {"event_count": 0, "data_input_name": "jamfmobiledevices", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_started", "validation_id": "v_1652891140_88", "progress": 0.6071428571428571}}