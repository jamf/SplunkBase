{"validation": {"validation_id": "v_1580846074_96", "progress": 1.0, "status": "job_finished", "validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"]}, "basic_builder": {"tab_version": "2.2.0", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAACmklEQVRYR2P8////f4ZBBBhBDpq1+tide0/eqFDiLgUZ4TsZodYUmQGyH+ygiv5NlLgFrrej0O8PAwMDCyWGUdtBlLgFrHf4OkhGgv9uTqS9MqVBRLUQivI2ua+nJqWIxUG/3n78+u7Zy48C33/+Yv7/j+E3uhpmVmYmQ3VpRmZmJnaqOagkwemLiCAPD5Jl/6etOPLhycv3fP/+/WcmFHKsrMw/m3O8qeegtnzfb0xMjFwgiz99+fG6fe5uof9EOATZoR2FftRJ1NycbJ9rMzx4oYb/qJywie3/fwYmQqGCLk81B8lJCn3LirABh87kZYe+Pn35gZtUx4DUU81BAc56Nyz0FDR+/f77uW7KVlhIkewmqjmoo9DvMwMDA+/5G09ur9x+TpVkl0A1UMVBzEyMf1rzfcHVRe3krd9///nLOaAOSg+zeasoLSQMcgSldSLFIaSnJvkkyttUBuSYU5cf3ly356I6uaFDcaL2d9S7a2mgAK8qehbs+/jm/Rd+qjjoyp3ntzcfuCL69+8/RmwGggRZWVj+8XCxsRhpybyw0FcEtXvgav/++/eteuIWcLanBMCjjBJDQHrvPXn7YdbqowKUmkM1B01YvP/Rizef5QaNgyjNXTCPUCWE3n74erl7/l5dSkMHJZdRYtjkZYc/P335nuzqAmttT66Dfv/5+6l28lY+cvXjrO3JNXDa8sOPH714L0uufqo6aO7a469vP3otSi3HoKehv5++/Pj09x/2ghGkGCT37fsvtjuP3t7fdey6FjUdgpHLOubs+vzh8w+qJExKHEpx5UqJ5dj0jjqIUIiOhtDQDaHG6ds/ff/xm2pVAKGQwCavpSRxM87fTB3ct4cq+MXAwPCPHMOooIeVgYEB3P8HAKcSp6SRyzYwAAAAAElFTkSuQmCC", "friendly_name": "Jamf Pro Add-on", "description": "This connects the JAMF Pro Classic API data sources to a Splunk instance", "author": "JAMF : Research", "theme": "#3c6188", "tab_build_no": "12", "appname": "JAMF-Pro-addon-for-splunk", "visible": true, "build_no": 11, "version": "1.0.5", "large_icon": "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"}, "data_input_builder": {"datainputs": [{"customized_options": [{"value": "test", "name": "name_of_the_modular_input"}, {"value": "jss01.jamf.demo", "name": "jss_url"}, {"value": "admin", "name": "username"}, {"value": "custom", "name": "api_call"}, {"value": "/JSSResource/computers", "name": "search_name"}, {"value": "", "name": "custom_host_name"}, {"value": "", "name": "custom_index_name"}], "description": "", "use_external_validation": true, "parameters": [{"placeholder": "", "value": "test", "type": "text", "label": "Name of the Modular Input", "help_string": "Unique Input Name for the data ", "required": true, "format_type": "text", "default_value": "", "name": "name_of_the_modular_input"}, {"placeholder": "", "value": "jss01.jamf.demo", "type": "text", "label": "JSS URL", "help_string": "Base URL for JAMF instance", "required": true, "format_type": "text", "default_value": "", "name": "jss_url"}, {"placeholder": "", "value": "admin", "type": "text", "label": "Username", "help_string": "", "required": true, "format_type": "text", "default_value": "", "name": "username"}, {"placeholder": "", "value": "jamf1234", "type": "password", "label": "Password", "help_string": "", "required": true, "format_type": "password", "default_value": "", "name": "password"}, {"value": "custom", "type": "radiogroup", "label": "API Call Name", "help_string": "API Call Name", "required": true, "format_type": "radiogroup", "default_value": "", "possible_values": [{"value": "computer", "label": "Computers"}, {"value": "mobile_device", "label": "Mobile Devices"}, {"value": "custom", "label": "Custom API"}], "name": "api_call"}, {"placeholder": "", "value": "/JSSResource/computers", "type": "text", "label": "Search Name", "help_string": "Preconfigured Advanced Search to call or Custom API call, refer to documentation", "required": true, "format_type": "text", "default_value": "", "name": "search_name"}, {"placeholder": "", "value": "", "type": "text", "label": "Custom Host Name", "help_string": "", "required": false, "format_type": "text", "default_value": "", "name": "custom_host_name"}, {"placeholder": "", "value": "", "type": "text", "label": "Custom Index Name", "help_string": "", "required": false, "format_type": "text", "default_value": "", "name": "custom_index_name"}], "title": "jamf", "index": "default", "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport requests\nimport json\nimport math\nfrom splunklib.modularinput import *\ntry:\n    import xml.etree.cElementTree as ElementTree\nexcept ImportError:\n    import xml.etree.ElementTree as ElementTree\nimport uuid\nimport time\n\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # name_of_the_modular_input = definition.parameters.get('name_of_the_modular_input', None)\n    # jss_url = definition.parameters.get('jss_url', None)\n    # api_call = definition.parameters.get('api_call', None)\n    # search_name = definition.parameters.get('search_name', None)\n    # custom_index_name = definition.parameters.get('custom_index_name', None)\n    # custom_host_name = definition.parameters.get('custom_host_name', None)\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    pass\n\ndef collect_events(helper, ew):\n    name_of_the_modular_input = helper.get_arg('name_of_the_modular_input', None)\n    url = helper.get_arg('jss_url', None)\n    api_call = helper.get_arg('api_call', None)\n    search_name = helper.get_arg('search_name', None)\n    username = helper.get_arg('username',None)\n    password = helper.get_arg('password',None)\n    index = helper.get_arg('custom_index_name','main')\n    host = helper.get_arg('custom_host_name','localhost')\n    maxCharLength = 10000\n    call_uuid = uuid.uuid4()\n    \n    #\n    #   Verify JSS URL\n    #\n    if url.__contains__(\"http://\"):\n        url = url.replace(\"http://\",\"\")\n    if url.__contains__(\"https://\"):\n        url = url.replace(\"https://\",\"\")\n    if not url.endswith(\"/\"):\n        url = url + \"/\"\n    url = \"https://\" + url\n    \n    \n    def writeComputerDevice (DATA): \n        #\n        #   List of things that will be written by themselves\n        #\n        chunk_list = list()\n        chunk_list.append(\"computer_groups\")\n        chunk_list.append(\"configuration_profiles\")\n        chunk_list.append(\"software\")\n        chunk_list.append(\"extension_attributes\")\n        chunk_list.append(\"hardware\")\n        chunk_list.append(\"running_services\")\n        chunk_list.append(\"certificates\")\n        chunk_list.append(\"location\")\n        chunk_list.append(\"purchasing\")\n        chunk_list.append(\"groups_accounts\")\n        chunk_list.append(\"general\")\n        \n        computer = ElementTree.fromstring(DATA)\n        \n        self = ElementTree.Element(\"self\")\n        gen = computer.find(\"general\")\n        #inventory_time =int(int(gen.find(\"report_date_epoch\").text)/1000.)\n        inventory_time = time.strftime('%Y-%m-%d %H:%M:%S',  time.gmtime(int(gen.find(\"report_date_epoch\").text)/1000.))\n        jss_id = gen.find(\"id\").text\n        ElementTree.SubElement(self, 'inventory_time').text = inventory_time\n        ElementTree.SubElement(self, 'id').text = jss_id\n        ElementTree.SubElement(self, 'link').text = url+\"JSSResource/computerdevices/\"+jss_id\n        ElementTree.SubElement(self, 'udid').text = gen.find('udid').text\n        pagination = ElementTree.Element(\"pagination\")  \n        \n        \n        for keyValue in chunk_list:\n            \n            if computer.find(keyValue):\n\n                    \n                #\n                #   Split Running Services Off\n                #\n                \n                keyXML = computer.find(keyValue)\n                \n                # Get the lenght of the string representation of the XML document\n                key_char_length = ElementTree.tostring(keyXML).__len__()\n                if key_char_length < maxCharLength:\n                    #\n                    #   If this is under 10k just go ahead and write to the event reader\n                    #\n                    root = ElementTree.Element(\"computer\")\n                    \n                    chunk_ID = str(uuid.uuid4())\n                    chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(1)\n                    root.append(chunk_uuid)\n                    pagination.append(chunk_uuid)\n                    root.append(keyXML)\n                    root.append(self)\n\n                    writeStringTo_Event( ElementTree.tostring(root) )\n                else:\n                    #\n                    #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                    #\n                    \n                    \n                    chunk_ID = str(uuid.uuid4())\n                    num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                    #\n                    #   Create an array of XML documents\n                    #\n                    \n                    if keyValue == \"software\":\n                    #\n                    #   Remove Running Services\n                    #\n                        remove_from_software = list()\n                        remove_from_software.append(\"unix_executables\")\n                        remove_from_software.append(\"installed_by_casper\")\n                        remove_from_software.append(\"installed_by_installer_swu\")\n                        remove_from_software.append(\"cached_by_casper\")\n                        remove_from_software.append(\"available_software_updates\")\n                        remove_from_software.append(\"available_updates\")\n                        remove_from_software.append(\"fonts\")\n                        chunk_from_software = list()\n                        \n                        chunk_from_software.append('chunk_from_software')\n                        chunk_from_software.append('applications')\n                        chunk_from_software.append('running_services')\n                        \n                        for remove in remove_from_software:\n                            if keyXML.find(remove):\n                                keyXML.remove((keyXML.find(remove)))\n                        \n                        \n                        run_service = keyXML.find(\"running_services\")\n                        run_serv_lengt = ElementTree.tostring(run_service).__len__()\n                        run_serv_count = math.ceil(run_serv_lengt / maxCharLength) + 2\n                        root_list = []\n                        for i in range(0, int(run_serv_count)):\n                            run_root = ElementTree.Element(\"running_services\")\n                            root_list.append(run_root)\n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n        \n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = run_service.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, run_serv_count))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n        \n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"computer\")\n                            gen = computer.find(\"general\")\n                            jss_id = gen.find(\"id\").text\n                            ElementTree.SubElement(root, 'id').text = jss_id\n        \n                            root.append(fin_xml)\n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                            root.append(chunk_uuid)\n                            #writeStringTo_Event( ElementTree.tostring(root) )\n                            writeStringTo_Event_wTime( ElementTree.tostring(root), inventory_time )\n                        chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                        ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                        ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                        ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                        pagination.append(chunk_uuid)\n                        \n                        keyXML.remove(run_service)\n                    #\n                    #   End Removing Running Services\n                    #\n                    \n                    \n                    \n                    root_list = []\n                    for i in range(0, int(num_XML)):\n                        root = ElementTree.Element(keyValue)\n                        root_list.append(root)\n                    #\n                    #   Get a list of the 1st level children in the XML document keeping the same structure\n                    #\n    \n                    #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                    key_chield = keyXML.getchildren()\n                    i = 0\n                    for child in key_chield:\n                        # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                        root_list[int(math.fmod(i, num_XML))].append(child)\n                        i = i + 1\n                    #\n                    #   Iterate through the finished XML documents and write to the event writer.\n                    #\n    \n                    for fin_xml in root_list:\n                        root = ElementTree.Element(\"computer\")\n                        gen = computer.find(\"general\")\n                        jss_id = gen.find(\"id\").text\n                        ElementTree.SubElement(root, 'id').text = jss_id\n\n                        root.append(fin_xml)\n                        chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                        ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n\n                        root.append(chunk_uuid)\n                        #writeStringTo_Event( ElementTree.tostring(root) )\n                        writeStringTo_Event_wTime( ElementTree.tostring(root), inventory_time )\n                    chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n\n                    pagination.append(chunk_uuid)\n                    \n\n                #\n                #   Remove the Key Index field from the XML\n                #\n                \n                computer.remove(keyXML)\n        #\n        # What's Left\n        #\n        self.append(pagination)\n        computer.append(self)\n        #writeStringTo_Event( ElementTree.tostring(computer) )\n        writeStringTo_Event_wTime( ElementTree.tostring(computer), inventory_time )\n    #\n    #   Done with Parsing computer Devices\n    #\n    \n    \n    def writeMobileDevice (DATA): \n        #\n        #   List of things that will be written by themselves\n        #\n        chunk_list = list()\n        chunk_list.append(\"mobile_device_groups\")\n        chunk_list.append(\"configuration_profiles\")\n        chunk_list.append(\"applications\")\n        chunk_list.append(\"extension_attributes\")\n        \n        mobile_device = ElementTree.fromstring(DATA)\n        self = ElementTree.Element(\"self\")\n        gen = mobile_device.find(\"general\")\n        jss_id = gen.find(\"id\").text\n        ElementTree.SubElement(self, 'id').text = jss_id\n        ElementTree.SubElement(self, 'link').text = url+\"/JSSResource/mobiledevices/\"+jss_id\n        pagination = ElementTree.Element(\"pagination\")  \n    \n        \n        for keyValue in chunk_list:\n\n            if mobile_device.find(keyValue):\n                keyXML = mobile_device.find(keyValue)\n                # Get the lenght of the string representation of the XML document\n                key_char_length = ElementTree.tostring(keyXML).__len__()\n                if key_char_length < maxCharLength:\n                    #\n                    #   If this is under 10k just go ahead and write to the event reader\n                    #\n                    root = ElementTree.Element(\"mobile_device\")\n                    \n                    chunk_ID = str(uuid.uuid4())\n                    chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(1)\n                    root.append(chunk_uuid)\n                    pagination.append(chunk_uuid)\n                    root.append(keyXML)\n                    root.append(self)\n\n                    writeStringTo_Event( ElementTree.tostring(root) )\n                else:\n                    #\n                    #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                    #\n                    chunk_ID = str(uuid.uuid4())\n                    num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                    #\n                    #   Create an array of XML documents\n                    #\n                    root_list = []\n                    for i in range(0, int(num_XML)):\n                        root = ElementTree.Element(keyValue)\n                        root_list.append(root)\n                    #\n                    #   Get a list of the 1st level children in the XML document keeping the same structure\n                    #\n    \n                    #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                    key_chield = keyXML.getchildren()\n                    i = 0\n                    for child in key_chield:\n                        # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                        root_list[int(math.fmod(i, num_XML))].append(child)\n                        i = i + 1\n                    #\n                    #   Iterate through the finished XML documents and write to the event writer.\n                    #\n    \n                    for fin_xml in root_list:\n                        root = ElementTree.Element(\"mobile_device\")\n                        gen = mobile_device.find(\"general\")\n                        jss_id = gen.find(\"id\").text\n                        ElementTree.SubElement(root, 'id').text = jss_id\n\n                        root.append(fin_xml)\n                        chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                        ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                        ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                        ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                        root.append(chunk_uuid)\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                    chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                    pagination.append(chunk_uuid)\n                    \n\n                #\n                #   Remove the Key Index field from the XML\n                #\n                \n                mobile_device.remove(keyXML)\n        #\n        # What's Left\n        #\n        self.append(pagination)\n        mobile_device.append(self)\n        writeStringTo_Event(ElementTree.tostring(mobile_device))\n    #\n    #   Done with Parsing Mobile Devices\n    #\n        \n    def writeStringTo_Event_withParsing (DATA):\n        if DATA.__len__() <maxCharLength:\n            writeStringTo_Event( DATA )\n        else:\n            if DATA.__contains__(\"<mobile_device>\"):\n                writeMobileDevice(DATA)\n            if DATA.__contains__(\"<computer>\"):\n                writeComputerDevice (DATA)\n            \n    \n    def writeStringTo_Event( event_string ):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #   \n        #\n        if event_string.__len__() < maxCharLength:\n                event = helper.new_event(data=event_string, index=index, host=host)\n                ew.write_event(event)\n                return True\n        else:\n            root = ElementTree.Element(\"XML_TooLong\")\n            ElementTree.SubElement(root, 'error').text = \"The XML was too long\"\n            writeStringTo_Event( ElementTree.tostring(root) )\n            \n            \n            root = ElementTree.fromstring(event_string)\n            children = root.getchildren\n            \n            debug = True\n            if debug:\n                event = helper.new_event(data=str(event_string.__len__()), index=index, host=host)\n                ew.write_event(event)\n            \n            #for n in children\n            #    writeStringTo_Event(ElementTree.tostring(n))\n            #for self in root.find('self'):\n                #writeStringTo_Event( ElementTree.tostring(self))\n\n        return False\n        \n    def writeStringTo_Event_wTime( event_string, event_time ):\n        #\n        #   This class is to help with the writing to the Splunk Event writer\n        #   \n        #\n        if event_string.__len__() < maxCharLength:\n                event = helper.new_event(data=event_string, index=index, host=host, time = event_time)\n                ew.write_event(event)\n                return True\n        else:\n            root = ElementTree.Element(\"XML_TooLong\")\n            ElementTree.SubElement(root, 'error').text = \"The XML was too long\"\n            writeStringTo_Event( ElementTree.tostring(root) )\n            \n            \n            root = ElementTree.fromstring(event_string)\n            children = root.getchildren\n            \n            debug = True\n            if debug:\n                event = helper.new_event(data=str(event_string.__len__()), index=index, host=host)\n                ew.write_event(event)\n            \n            #for n in children\n            #    writeStringTo_Event(ElementTree.tostring(n))\n            #for self in root.find('self'):\n                #writeStringTo_Event( ElementTree.tostring(self))\n\n        return False\n    \n    api_retries = 0\n    \n    def api_get_Call(endPoint):\n\n        #\n        #   JSSResources API Call\n        #\n        \n        api_family = \"\"\n        if endPoint.__contains__(\"uapi/\"):\n            api_family = \"uapi\"\n        if endPoint.__contains__(\"JSSResource/\"):\n            api_family = \"classic\"\n        \n        if api_family == \"classic\":  \n            context = None\n            isDone = False\n            tryCount = 0\n            while not isDone:\n                try:\n                    \n                    r =  requests.get(endPoint, auth=(username, password), headers={'Accept': 'application/xml'}, verify=False)\n                    status_code = r.status_code\n                    resp = r.content\n                    # https://developer.jamf.com/documentation for status code information\n                    if (status_code == 200):\n                        #   Request successful\n                        isDone = True\n                        context = r.content\n                    if (status_code == 201):\n                        #   Request to create or update object successful\n                        context = r.content\n                    if (status_code == 400):\n                        #   Bad request. Verify the syntax of the request specifically the XML body.\n                        pass\n                    if (status_code == 401):\n                        root = ElementTree.Element(\"XML_TooLong\")\n                        ElementTree.SubElement(root, 'error').text = \"API Auth Error\"\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                        context = ElementTree.Element(\"error\")\n                        isDone = True\n                        pass\n                    if (status_code == 403):\n                        #   Invalid permissions. Verify the account being used has the proper permissions for the object/resource you are trying to access.\n                        pass\n                    if (status_code == 404):\n                        #   Object or resouce is not found\n                        pass\n                    if (status_code == 409):\n                        #   Conflict\n                        pass\n                    if (status_code == 500):\n                        #   Internal server error. Retry the request or contact Jamf support if the error is persistent.\n                        pass\n                    \n                except requests.exceptions.Timeout:\n                    isDone = isDone + 1\n                    if isDone > 3:\n                        root = ElementTree.Element(\"XML_TooLong\")\n                        ElementTree.SubElement(root, 'error').text = \"Too Many Timeouts\"\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                        context = ElementTree.Element(\"error\")\n                    pass\n                except requests.exceptions.TooManyRedirects:\n                    root = ElementTree.Element(\"XML_TooLong\")\n                    ElementTree.SubElement(root, 'error').text = \"Too Many Redirects\"\n                    writeStringTo_Event( ElementTree.tostring(root) )\n                    context = ElementTree.Element(\"error\")\n                    pass\n        \n                except requests.exceptions.RequestException as e:\n                    root = ElementTree.Element(\"XML_TooLong\")\n                    ElementTree.SubElement(root, 'error').text = \"API Error Request Exception\"\n                    writeStringTo_Event( ElementTree.tostring(root) )\n                    context = ElementTree.Element(\"error\")\n                    pass\n                finally:\n                    pass\n    \n        \n        \n        return context\n        #\n        #   End of the API Call Function\n        #\n        \n        \n\n    # Log that we are beginning to retrieve data.\n    helper.log_debug(\"Started retrieving data for user %s\" % username)\n    \n    #helper.log_debug(response.content)\n    if api_call == \"computer\":\n        #\n        #   make the API Call\n        #\n        jss_url = \"%sJSSResource/advancedcomputersearches/name/%s\" % (url, search_name)\n        response = requests.get(jss_url, auth=(username, password), headers={'Accept': 'application/xml'},verify=False)\n        tree = ElementTree.fromstring(response.content)\n        #\n        #   Start Advanced Computer\n        #\n        \n        #\n        #   Chunk list is a list of the XML fields that we want to farm out to their own XML data sets\n        #\n        chunk_list = list()\n        #chunk_list.append(\"Applications\")\n        #chunk_list.append(\"Computer_Group\")\n        chunk_list.append(\"Running_Services\")\n        \n        #\n        #   Pull the computers out of the Advanced Computer Search\n        #\n        \n        computers_list = tree.find('computers')\n        computers = computers_list.findall('computer')\n        for computer in computers:\n            \n            #\n            #   keyValue is an Abstract name for the values in Chunk List it will pull it out of the primary XML\n            #\n            for keyValue in chunk_list:\n                if computer.find(keyValue):\n                    keyXML = computer.find(keyValue)\n                    # Get the lenght of the string representation of the XML document\n                    key_char_length = ElementTree.tostring(keyXML).__len__()\n                    if key_char_length < maxCharLength:\n                        #\n                        #   If this is under 10k just go ahead and write to the event reader\n                        #\n                        root = ElementTree.Element(\"computer\")\n                        ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                        root.append(keyXML)\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                    else:\n                        #\n                        #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                        #\n                        chunk_ID = str(uuid.uuid4())\n                        num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                        #\n                        #   Create an array of XML documents\n                        #\n                        root_list = []\n                        for i in range(0, int(num_XML)):\n                            root = ElementTree.Element(keyValue)\n                            root_list.append(root)\n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n        \n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = keyXML.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, num_XML))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n        \n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"computer\")\n                            ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                            root.append(fin_xml)\n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(root_list.__len__())\n                            root.append(chunk_uuid)\n                            \n                            #writeStringTo_Event( ElementTree.tostring(chunk_uuid) )\n                            \n                            writeStringTo_Event( ElementTree.tostring(root) )\n\n                    #\n                    #   Remove the Key Index field from the XML\n                    #\n                    computer.remove(keyXML)\n            #\n            #   Post Data chunking... This *should* be under 10k char now, tune it with chunk list\n            #\n        \n            data = ElementTree.tostring(computer)\n        \n            #\n            #   Check to see if it needs chunking and if it still needs it chunk it on childs\n            #\n            if data.__len__() < maxCharLength:\n                #print (data)\n                writeStringTo_Event( data )\n                \n            else:\n                num_XML = math.ceil(data.__len__() / maxCharLength) + 1\n                #\n                #   Create an array of XML documents\n                #\n                root_list = []\n                chunk_ID = str(uuid.uuid4())\n                for i in range(0, int(num_XML)):\n                    root = ElementTree.Element(\"computer\")\n                    ElementTree.SubElement(root, 'id').text = computer.find(\"id\").text\n                    chunk_uuid = ElementTree.Element(\"pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i+1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                    root.append(chunk_uuid)\n                    \n                    root_list.append(root)\n                    \n                #\n                #   Get a list of the 1st level children in the XML document keeping the same structure\n                #\n        \n                #\n                #   Need to remove ID from XML since it will be a duplicate in 1 of them.\n                #\n                \n                computer.remove(computer.find(\"id\"))\n                #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                key_chield = computer.getchildren()\n                i = 0\n                for child in key_chield:\n                    # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                    root_list[int(math.fmod(i, num_XML))].append(child)\n                    i = i + 1\n                #\n                #   Iterate through the finished XML documents and write to the event writer.\n                #\n        \n                for fin_xml in root_list:\n                    writeStringTo_Event( ElementTree.tostring(fin_xml))\n        \n            #\n            # End of Computers For Loop\n            #\n        #\n        # End of Advanced Computers Section\n        #\n\n    elif api_call == \"mobile_device\":\n        jss_url = \"%sJSSResource/advancedmobiledevicesearches/name/%s\" % (url, search_name)\n        response = requests.get(jss_url, auth=(username, password), headers={'Accept': 'application/xml'},verify=False)\n        tree = ElementTree.fromstring(response.content)\n        \n        #\n        #   Chunk list is a list of the XML fields that we want to farm out to their own XML data sets\n        #\n        chunk_list = list()\n        chunk_list.append(\"Display_Name\")\n        chunk_list.append(\"Capacity_MB\")\n        chunk_list.append(\"Device_Locator_Service_Enabled\")\n        \n        \n        mobile_devices_list = tree.find('mobile_devices')\n        mobile_devices = mobile_devices_list.findall('mobile_device')\n        for mobile_device in mobile_devices:\n            #\n            #   keyValue is an Abstract name for the values in Chunk List it will pull it out of the primary XML\n            #\n            for keyValue in chunk_list:\n                if mobile_device.findall(keyValue):\n                    #event = helper.new_event(data=keyValue, index=index, host=host)\n                    #ew.write_event(event)\n                    keyXML = mobile_device.find(keyValue)\n                    # Get the lenght of the string representation of the XML document\n                    key_char_length = ElementTree.tostring(keyXML).__len__()\n                    if key_char_length < maxCharLength:\n                        #\n                        #   If this is under 10k just go ahead and write to the event reader\n                        #\n        \n                        root = ElementTree.Element(\"mobile_device\")\n                        ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                        sub_root =  ElementTree.Element(keyValue)\n                        root.append(keyXML)\n                        #print(ElementTree.tostring(root))\n                        writeStringTo_Event( ElementTree.tostring(root) )\n                    else:\n                        #\n                        #   This is the area for if the already seperated XML is still too large. It will take the Length and use MOD to give the number of XML files it would need to be cut into. I add an additional one just in c\n                        #\n                        \n                        num_XML = math.ceil(key_char_length / maxCharLength) + 1\n                        \n                        \n                        \n                        #\n                        #   Create an array of XML documents\n                        #\n                        chunk_ID = uuid.uuid4()\n                        root_list = []\n                        for i in range(0, int(num_XML)):\n                            root = ElementTree.Element(keyValue)\n                            root_list.append(root)\n                            \n                        #\n                        #   Get a list of the 1st level children in the XML document keeping the same structure\n                        #\n        \n                        #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                        key_chield = keyXML.getchildren()\n                        i = 0\n                        for child in key_chield:\n                            # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                            root_list[int(math.fmod(i, num_XML))].append(child)\n                            i = i + 1\n                        #\n                        #   Iterate through the finished XML documents and write to the event writer.\n                        #\n        \n                        for fin_xml in root_list:\n                            root = ElementTree.Element(\"mobile_device\")\n                            ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                            root.append(fin_xml)\n                            event = helper.new_event(data=ElementTree.tostring(fin_xml), index=index, host=host)\n                \n                            chunk_uuid = ElementTree.Element(\"sub_pagination\")\n                            ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                            ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i+1)\n                            ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                            \n                            #Finally Write it\n                            writeStringTo_Event( ElementTree.tostring(fin_xml) )\n                    #\n                    #   Remove the Key Index field from the XML\n                    #\n                    mobile_device.remove(keyXML)\n            #\n            #   Post Data chunking... This *should* be under 10k char now, tune it with chunk list\n            #\n        \n            data = ElementTree.tostring(mobile_device)\n        \n            #\n            #   Check to see if it needs chunking and if it still needs it chunk it on childs\n            #\n            if data.__len__() < maxCharLength:\n                writeStringTo_Event( data )\n            else:\n                num_XML = math.ceil(data.__len__() / maxCharLength) + 1\n                #\n                #   Create an array of XML documents\n                #\n                chunk_ID = str(uuid.uuid4())\n                root_list = []\n                for i in range(0, int(num_XML)):\n                    root = ElementTree.Element(\"mobile_device\")\n                    ElementTree.SubElement(root, 'id').text = mobile_device.find(\"id\").text\n                    chunk_uuid = ElementTree.Element(\"pagination\")\n                    ElementTree.SubElement(chunk_uuid, 'uuid').text = chunk_ID\n                    ElementTree.SubElement(chunk_uuid, 'chunk_number').text = str(i+1)\n                    ElementTree.SubElement(chunk_uuid, 'chunk_size').text = str(int(num_XML))\n                    root.append(chunk_uuid)\n                    root_list.append(root)\n                #\n                #   Get a list of the 1st level children in the XML document keeping the same structure\n                #\n        \n                #\n                #   Need to remove ID from XML since it will be a duplicate in 1 of them.\n                #\n                mobile_device.remove(mobile_device.find(\"id\"))\n                #   Careful about the below call it is gone after 3.7 python new list function from 3.1 was introduced need to swith the call type\n                key_chield = mobile_device.getchildren()\n                i = 0\n                for child in key_chield:\n                    # print(\"inserting into array number: \"+str(int(math.fmod(i,num_XML))))\n                    root_list[int(math.fmod(i, num_XML))].append(child)\n                    i = i + 1\n                #\n                #   Iterate through the finished XML documents and write to the event writer.\n                #\n        \n                for fin_xml in root_list:\n                    #print(ElementTree.tostring(fin_xml))\n                    event = helper.new_event(data=ElementTree.tostring(fin_xml), index=index, host=host)\n                    writeStringTo_Event( ElementTree.tostring(fin_xml) )\n        \n            #\n            # End of mobile_devices For Loop\n            #\n        #\n        # End of Advanced mobile_devices Section\n        #\n        \n\n        \n    elif api_call == \"custom\":\n        #\n        #   is By ITER or by single call\n        #\n        \n        #\n        #   URL Clean up stuff\n        #\n        \n        if search_name.startswith(\"/\"):\n            search_name = search_name.replace(\"/\",\"\",1)\n            \n        if search_name.endswith(\"/\"):\n            search_name = search_name[:-1]\n            \n        jss_url = url + search_name\n        \n        resp_string = api_get_Call(jss_url)\n        resp_xml = ElementTree.fromstring(api_get_Call(jss_url))\n        \n        if search_name.__contains__(\"/name/\"):\n            writeStringTo_Event( resp_string )\n            return\n        elif search_name.__contains__(\"/id/\"):\n            if search_name.__contains__(\"/computers/\"):\n                writeComputerDevice( resp_string )\n            else:\n                writeStringTo_Event( resp_string )\n            return\n        else:\n            children = resp_xml.getchildren()\n            for name in children:\n                if name.findall(\"id\"):\n                    newCall = jss_url +\"/id/\"+name.find(\"id\").text\n                    data = api_get_Call(newCall)\n                    writeStringTo_Event_withParsing( data )\n                    \n    #\n    #   Start Here For Async Tests\n    #\n    \n\n\n    ", "data_inputs_options": [{"required_on_create": true, "description": "Unique Input Name for the data ", "type": "customized_var", "title": "Name of the Modular Input", "placeholder": "", "format_type": "text", "default_value": "", "required_on_edit": false, "name": "name_of_the_modular_input"}, {"required_on_create": true, "description": "Base URL for JAMF instance", "type": "customized_var", "title": "JSS URL", "placeholder": "", "format_type": "text", "default_value": "", "required_on_edit": false, "name": "jss_url"}, {"required_on_create": true, "description": "", "type": "customized_var", "title": "Username", "placeholder": "", "format_type": "text", "default_value": "", "required_on_edit": false, "name": "username"}, {"required_on_create": true, "description": "", "type": "customized_var", "title": "Password", "placeholder": "", "format_type": "password", "default_value": "", "required_on_edit": false, "name": "password"}, {"required_on_create": true, "description": "API Call Name", "type": "customized_var", "title": "API Call Name", "format_type": "radiogroup", "default_value": "", "possible_values": [{"value": "computer", "label": "Computers"}, {"value": "mobile_device", "label": "Mobile Devices"}, {"value": "custom", "label": "Custom API"}], "required_on_edit": false, "name": "api_call"}, {"required_on_create": true, "description": "Preconfigured Advanced Search to call or Custom API call, refer to documentation", "type": "customized_var", "title": "Search Name", "placeholder": "", "format_type": "text", "default_value": "", "required_on_edit": false, "name": "search_name"}, {"required_on_create": false, "description": "", "type": "customized_var", "title": "Custom Host Name", "placeholder": "", "format_type": "text", "default_value": "", "required_on_edit": false, "name": "custom_host_name"}, {"required_on_create": false, "description": "", "type": "customized_var", "title": "Custom Index Name", "placeholder": "", "format_type": "text", "default_value": "", "required_on_edit": false, "name": "custom_index_name"}], "type": "customized", "uuid": "1c09cb214a8442d486dc65548d0c6da3", "streaming_mode_xml": true, "sample_count": "6175505", "sourcetype": "JamfModularInput", "interval": "3600", "name": "jamf"}]}, "global_settings_builder": {"global_settings": {"log_settings": {}}}, "field_extraction_builder": {"JamfModularInput": {"is_parsed": true, "data_format": "xml"}}, "sourcetype_builder": {"jamf_test": {"metadata": {"cims_count": 0, "event_count": 0, "data_input_name": null, "extractions_count": 0}}, "JamfModularInput": {"metadata": {"cims_count": 0, "event_count": 0, "data_input_name": "jamf", "extractions_count": 0}}}}